### 20211109
[브라우저의 사용자 에이전트는 왜 이렇게 복잡하게 생겼을까?](https://wormwlrm.github.io/2021/10/11/Why-User-Agent-string-is-so-complex.html)
  - 인터넷 익스플로러(IE)가 넷스케이프 브라우저의 UA를 흉내냄으로써, 처음으로 UA가 더럽혀지기 시작했다.
  - 모질라 재단이 넷스케이프 브라우저의 렌더 엔진을 오픈소스 프로젝트로 공개한 후부터는 브라우저 렌더 엔진 정보도 UA에 추가되기 시작했다.
  - 브라우저 전쟁 이후 다양한 브라우저가 생겼는데, 호환성을 유지하기 위해 기존 브라우저 UA에 스트링을 계속 덧붙이다보니 지금과 같은 끔찍한 형태가 되어버렸다.

[[브라우저엔진] 브라우저 렌더링 엔진](https://12bme.tistory.com/208)
  - HTML, CSS parsing
  - Render Tree 구축
  - Layout
  - Paint
  - Chrome - Blink
  - Safari - Webkit
  - Firefox - Gecko

[4 Essential Tips for Better Asynchronous Code in JavaScript](https://www.ditdot.hr/en/4-tips-better-asynchronous-javascript-code)
  - Promise.all 사용
  - map 으로 Promise array 만들어서 Promise.all 사용
  - sequential 하게 하려면 for await () 사용
  - Promise.allSettled 도 때에 따라 사용
  - Promise.all vs Promise.allSettled 는 Promise.all 은 하나라도 reject 되면 바로 에러냄

### 20211108
[logN의 시간 복잡도가 나오는 이유](https://neos518.tistory.com/145)
  - 이진 탐색트의 경우 시간 복잡도가 logN 인데 이해 대한 명쾌한 설명!

### 20211106
[FrontEndCollection](https://github.com/cheatsheet1999/FrontEndCollection)
  - 일반적인 data structure, 알고리즘, 기본 웹 개념, HTML, CSS 관하여...

[Debug Faster in JavaScript!](https://javascript.plainenglish.io/debug-faster-in-javascript-26d2ad3942d9)
  - 기본적으로 디버깅 하는 방법 같은거
  - console.log, console.error, console.warn, console.table, Debugger 등등

[Mocking으로 생산성까지 챙기는 FE 개발](https://tech.kakao.com/2021/09/29/mocking-fe/)
  - MSW.js 를 사용하여 mocking api 를 만들어 백엔드에 영향 없이 프론트엔드 개발
  - 지금은 풀스택으로 일하고 있어서 크게 의미는 없지만 나중에 프론트 개발만 할때는 용이하게 사용할 수 있을듯.

[React Derived State 다시 보기](https://reactiver.dev/review-react-derived-state/)
  - 잘 모르면 종종 실수 할 수도 있는 패턴
  - 하지만 안티패턴이라고 생각되고 initial value 는 initial value 여야 한다고 생각함 그렇게 initial value 로 지정하면 더이상 그 컴포넌트는 내부 상태에만 관여하는게 맞다고 생각이듬
  - initial value 인데 바뀌면 이상...
  - FULLY CONTROLLED COMPONENT 와 FULLY UNCONTROLLED COMPONENT + KEY 방법이 있는데 전자의 방법이 낫다고 생각함

[A Visual Guide to React Rendering - Cheat Sheet](https://alexsidorenko.com/blog/react-render-cheat-sheet/)
  - Standard rendering and memo
  - Primitive vs Non-primitive props
  - Stable reference with useMemo
  - Stable reference with useCallback
  - Rendering and Context
    - The component right under your context provider should probably use memo
  - Rendering and DOM
    - 리렌더랑 DOM 업데이트는 다르다.

[JS의 객체는 hash table이 아닙니다!](https://velog.io/@wongue_shin/JS%EC%9D%98-%EA%B0%9D%EC%B2%B4%EB%8A%94-hash-table%EC%9D%B4-%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4#)
  - typeof array 부터 해서 JS 객체에 대해 알아가는 과정
  - 일단 결론부터 적자면 V8 엔진, 그러니까 Chromium을 사용하는 브라우저에서는 객체는 hash-table로 구현되지 않았습니다! 왜냐면 동적 타이핑 언어에서 해쉬 테이블은 느리기 때문입니다.
  - 동적 타이핑 언어는 컴파일 시에 변수의 데이터 타입이 결정되지 않는다는 거고, 데이터 타입이 결정되지 않으면 메모리에서 데이터 오프셋을 얼마나 두어야 할지 알 수 없게 되고, 이는 런타임 중에 실제로 데이터가 저장되어있는 위치가 계속 바뀌거나 수정될 수 있다는 의미입니다. 따라서 런타임 중에 자꾸 변할 수 있는 변수의 참조 값을 읽어오는 행위를 동적 서치라고 하고 동적 서치의 비용은 반복되면 엄청나게 비싸지겠죠.
  - V8 엔진은 이러한 동적 서치를 가능한 줄일 수 있게, 객체의 구현에 Hidden class를 이용했습니다
  - JS Object가 해시 테이블로 구현되지 않는 이유는, 동적 타이핑 언어인 JS에서는 데이터의 오프셋이 런타임 중에 실시간으로 바뀌게 되고 해시 테이블은 프로퍼티의 생성, 변조에 따라 변경되는 오프셋을 최신 상태로 갱신해 담고 있다고 보장될 수 없기 때문에 엔진에서 데이터를 읽게 되는 모든 과정에 동적 서치가 필요하게 되기 때문입니다

### 20211105
[A deep dive into ES6 Classes](https://dev.to/mustapha/a-deep-dive-into-es6-classes-2h52)
  - JS 에서 클래스 쓰는것을 별로 좋아하진 않지만 써야하는 경우가 아주 많이 생김
  - 기본적인 JS class 설명

[상속할떄에 new Function() vs Object.create(Function.prototype) 에 차이](https://velog.io/@jinyongp/%EC%83%81%EC%86%8D%EC%9D%84-%ED%95%A0-%EB%95%8C-Object.create%EA%B3%BC-new-%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94)
  - 동작은 비슷하게 하나 불필요하게 프로퍼티들이 생성된다.

[Using Composition to reduce prop drilling in React](https://nitin-karthy.medium.com/using-composition-to-reduce-prop-drilling-in-react-375dafbb681d)
  - children을 사용해서 props drilling 없이 내려주는 형태
  - children을 사용 하거나 props 로 컴포넌트를 받아서 그려주거나 이런 형태로 많이들 사용하는 듯 하다.
  - 확실히 props drilling 보단 나아보이는 방법이긴 하나 전통적인 컴포넌트 형태 같진 않아서 아직 눈에 익숙하진 않은듯...

[그래서, 스택이랑 힙이 뭔데?](https://www.jiwon.me/explain-heap-and-stack/)
  - 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로, CPU는 여기에 저장된 명령어를 하나씩 가져가서 처리한다.
  - 데이터 영역은 프로그램의 전역 변수(global variable)와 정적 변수(static variable)이 저장되는 영역으로, 프로그램이 시작되는 때에 생성되며 프로그램이 종료되면 없어진다.
  - 힙 영역은 사용자가 직접 관리할 수 있는 영역으로, 사용자에 의해서 동적으로 할당되고 해제된다. 이때 할당 순서는 낮은 주소부터 높은 주소로 할당된다.
  - 스택 영역은 프로그램 함수의 지역 변수(local variable)와 매개변수(parameter)가 저장되는 영역으로, 함수가 호출되면 할당, 함수가 종료되면 해제된다. 다른 메모리 영역과 구분되는 스택 영역만의 특징은 '스택(stack)'구조라는 것이다. 스택 구조는 나중에 들어간 데이터가 먼저 나오는 구조(LIFO; Last In, First Out)로 push로 데이터를 저장하고 pop을 통해 스택의 제일 상단에 있는 데이터를 꺼낸다. 이때 할당 순서는 높은 주소부터 낮은 주소로 할당된다.

[Web2 vs Web3](https://dong-life.tistory.com/118)
  - 아직은 동 떨어져 있다고 생각하는 블록체인 이야기
  - web3 는 탈 중앙화
  - 탈 중앙화는 컨셉은 좋다고 생각함.

[Next.JS hydration 스타일 이슈 파악하기](https://fourwingsy.medium.com/next-js-hydration-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%9D%B4%EC%8A%88-%ED%94%BC%ED%95%B4%EA%B0%80%EA%B8%B0-988ce0d939e7)
  - Next js hydration 하는 방법을 잘 몰랐고 이글을 통하여 알게 되었다.
  - 한때 hydration error 가 나오기도 하였는데 이는 SSR, CSR 에 그려지는 dom 이 달라서 그러한것 같다.
  - 단순하게 return null 이 아닌 return <div /> 로 하는것이 에러를 피하는 방법인것 같다.
  - 또는 return null 대신 visibility: hidden; 또는 display: none;

[쿠버네티스 API서버는 정말 그냥 API서버라구욧](https://coffeewhale.com/apiserver)
  - kube-apiserver는 쿠버네티스 클러스터에 있어서 가장 중추적인 역할을 담당함
  - 따라서 복잡할것 이라고 생각이 들고 필자도 처음 접해봤을때에 어떻게 호출하는지 잘 몰라서 직접 요청 하는 경우가 거의 없었다고함
  - 하지만 알고보면 단순한 API 서버이다.
  - kube-apiserver 가 만들기 쉽고 별것 없다는 이야기가 아니라 표면적으로 누구나 사용하기 쉽게 잘 만들어진 REST API 서버이다.
  - kube-apiserver 가 뭔지 잘 모르겠으나 일단 이런게 있구나 정도....

[How to Write Clean JavaScript Code with Functional Programming](https://javascript.plainenglish.io/how-to-write-clean-javascript-code-with-functional-programming-54fd60a56074)
  - 방법론 적인 글은 아니고 FP 에 대한 찬양(?) 글
  - Immutable variables make it easier to read <- 상당부분 동의하고 나도 왠만하면 immutable 하게 만드려고함
  - Small scopes make it easier to break code <- 당연한 이야이기인듯, 함수는 한가지 일만!
  - It is easier to test <- immutable 하니 테스트가 용이하긴함
  - 직접적으로 딥하게 함수형을 사용하진 않았지만 왠만하면 함수형으로 사용하려고함
  - useEffect, map, forEach 등 다양한 방향에서 immutable 하게 객체를 수정하려고함

### 20211103
[typescript + node absolute path](https://medium.com/@jsh901220/typescript-node-absolute-path-5782b584e368)
  - typescript 에서 tsc 로 빌드시 absolute path가 자꾸 노드 package 를 참조한다.
  - 나는 tsc-alias 를 사용하였다.
  - [notion](https://www.notion.so/10-5dc760ecbc214bb38c9a16dbba2b6ad7#80ff7391f7dd49ee80ae97f3c67c3aba) 참고

[9 Best Practices for Optimizing Frontend Performance](https://blog.bitsrc.io/9-best-practices-for-optimizing-frontend-loading-time-763211621061)
  - Minify resource
  - Reduce Number of server calls
  - Remove unnecessary custom font
  - Compress files
  - Optimize image
  - Apply Lazy loading
  - Caching
  - Enable prefetching
  - Use CDN
  - 기본적인 이야기들, 하지만 효과는 있고 실제 할때 어떤 컨셉으로 갈지 정할 때 보면 좋을듯

[Will Rome Replace Webpack?](https://medium.com/weekly-webtips/will-rome-replace-webpack-a60e1a740222)
  - 기대하고 관심있게 보는 프로젝트 중 하나
  - [공식 문서](https://rome.tools/)

### 20211101
[WebComponent](https://github.com/yamoo9/WebComponent)
[HTML with Superpowers](https://daverupert.com/2021/10/html-with-superpowers/)
  - 웹컴포넌트에 대한 이야기
  - React, Vue, Angular 에 영향을 받아 특정한 모듈 없이 컴포넌트 처럼 사용하게끔 하려고 하는 기술인듯
  - 아직 실무에 사용하기에는 쉽지 않지만 커스텀 태그를 만들고 그 안에서 데이터를 핸들링 하는것이 초기 리액트와 비슷함

[Shadow DOM은 무엇일까?](https://wit.nts-corp.com/2019/03/27/5552)
  - 어떤 면에서 shadow DOM은 DOM의 “lite” 버전입니다. DOM과 같이 HTML 요소의 구조화된 표현이며, 페이지에 무엇을 표시할지 결정하고 요소의 수정을 가능하게 합니다. 하지만 DOM과 다르게 완전한 독립 문서를 기반으로 하지 않습니다.

[How to use Object Literals in JavaScript to write complex conditions?](https://medium.com/getpowerplay/how-to-use-object-literals-in-javascript-to-write-complex-conditions-94acadb0c2)
  - 한때 많이 사용하고 지금도 종종 사용하던 if-else 대신 object literal 로 컨디션 조절하기

[Writing Clean JavaScript — ES6 Edition](https://medium.com/geekculture/writing-clean-javascript-es6-edition-834e83abc746)
  - 가끔 다시 보면서 상기시킬만함
  - 변수
    - 의미 있는 네이밍
    - 불필요한 네이밍 제거
    - 하드코딩 노노
  - 함수
    - 기술적인 네이밍
    - Default argument 사용
    - argument 수의 limit 주기
    - 함수하나에는 하나의 역활만
    - 플래그 많이 쓰지 않기
    - 반복되면 함수로 분리
    - 사이드이펙트 조심
  - 컨디셔널
    - 부정 컨디션 사용 노노
    - 짧은 형식으로 표현
    - 퀵 리턴 사용하기
    - 객체 리터럴료 분기 타기
    - 옵셔널 체인징, nullish coalescing 사용하기
  - 동시성
    - 콜백 보다는 Promise, async/await
  - 에러 핸들링
    - 에러 잘 관리하기
  - 주석
    - 비지니스 로직에만 사용하기
    - 버전 컨트롤 노노
    - 왠만하면 문서로...

[API Gateway Throttling 구현](https://doublem.org/api-gateway-basic/)
  - API 요청에 속도와 횟수를 제한하는 것을 말한다.
  - Latency Bucket 방식과 Token Bucket 있다.
  - 잘은 모르겠고 아직 감이 안오지만 일단 저장!

[TypeScript Done Wrong](https://medium.com/stackanatomy/typescript-done-wrong-2406822973fb)
  - any 타입 사용하지 않기
  - 함수의 Function 타입 사용하지 않기
  - 객체의 타입 지정
  - Numeric enum 별로 안좋음
    - 어떤 변수의 enum 타입 지정해도 숫자로 변수의 할당 가능 (Notion 2021 11 월 참고)
  - private keyword 는 단순히 타입 체크 용도임
    - 실제 for...in 하면 private keyword 붙여도 나옴
    - any 타입으로 강제 치환 하면 접근 가능
    - 자바스크립트의 #을 붙여서 진짜 private 처럼 사용하기 (Terrible)