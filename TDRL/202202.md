### 20220213

[An Introduction to Deno: Is It Better than Node.js?](https://blog.appsignal.com/2022/02/09/an-introduction-to-deno-is-it-better-than-nodejs.html)

- 이제 Deno를 써볼때가...?
- Typescript first
- Permissions
- Dependency management
- Standard Library
- Using NPM Packages in Deno
- 과연 npm 을 뒤에 업은 node 만큼 커질 수 있을것인가...?

[CSS Animations Tutorial: Complete Guide for Beginners](https://themeisle.com/blog/css-animations-tutorial/)

- animation keyframes 와 각각에 속성에 대한 예제와 설명

[What is the Difference between the Node HTTP library, Express, and Nestjs?](https://levelup.gitconnected.com/what-is-the-difference-between-the-node-http-library-express-and-nestjs-df6a11ca0e48)
![](https://miro.medium.com/max/1400/1*K7dBheFdIunif6XzuxKhNA.png)

[Spring 개발자의 Nest Js 적응하기](https://medium.com/zigbang/spring-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-nestjs-%EC%A0%81%EC%9D%91%ED%95%98%EA%B8%B0-a816fa0f38a9)

- Nest JS 에서 사용하는 각각의 모듈(?) 에 대한 간단한 설명
- Controller, Provider, Modules, Middleware, Exceptions filter, Pipes, Guards, Interceptors
- 다 써보진 않았으나 대충 어떤 느낌인지는 앎

[Typescript: Type vs Interface](https://medium.com/@saif.adnan.it/type-vs-interface-in-typescript-8c6395c4a2d7)

- Type vs Interface 에 차이점 간략히...

[코드 리뷰의 목적은 성장이어야 한다](https://jbee.io/essay/code-review-goal/)

- 리뷰를 하면서 버그를 잡거나 코드를 공유하는것도 중요하지만 서로의 성장을 위해 해야한다는 말에 동감
- 그래야 코드 리뷰에 대한 병목도 사라질듯
- 또 영어로 코멘트 다는것도 나쁘지 않은 방법이라고 생각이 듬 (의사소통이 유해지면서)
- 머지에 대한 룰이 없고, 성장에 초점이 맞춰진것에 단점 (코드 컨벤션, 버그 등)은 테스트를 통해서 극복해 나아가는것도 좋은 방법이라고 생각함

[React 18 미리보기](https://gist.github.com/seonghyeonkimm/86411e2bf274063db45731c42b271033)

- Automatic batching for fewer renders
- SSR support for Suspense
- Behavioral changes to Suspense in React 18
- ConCurrent Features

[React Context Best Architecture Practices](https://javascript.plainenglish.io/react-context-best-architecture-practice-c7988c82d539)

- React Context 에서 useReducer 를 사용하여 작성하는 방법 소개
- 대부분 Context 를 사용하면 useReducer 를 사용하던데... 난 딱히 메리트를 잘 모르겠음

[3 Things You Should Always Unit Test When Using React With Redux](https://betterprogramming.pub/3-things-you-should-always-unit-test-when-using-react-with-redux-ee663c88e82d)

- Redux 에 reducer, selector, utils 성 코드 테스트 해야한다는 이야기

### 20220212

[How we migrated 541 components from Styled Components to Emotion with zero bugs](https://storybook.js.org/blog/541-components-from-styled-components-to-emotion/)

- Chromatic 을 이용하여 비주얼 체크를 통한 Styled Components to Emotion 변경
- 스토리북 배포할때 Chromatic 잠시 써봤었는데 컴포넌트 변경사항을 체크해주고 거기에 accept 해야 배포 가 되었던것 같다.

[[nodejs] Buffer를 얼마나 이해하고 있니?](https://blog.naver.com/pjt3591oo/222636629171)

- Buffer 에 관한 간략한 설명
- 데이터를 주고 받을때 사용하고 입력한 데이터를 UTF-8 로 인코딩 하여 데이터를 처리함

### 20220210

[(번역) How React server components work: an in-depth guide](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-how-react-server-components-work-an-in-depth-guide-aaf90ebd3c45)

- RSC 에 대한 설명
- 아직 확 와닿지는 않는다.
- 실제로 써봐야 어떤 느낌인지 알듯

### 20220207

[React Query vs SWR](https://javascript.plainenglish.io/react-query-vs-swr-36743c14ba7e)

- 별 의미가 없는 비교 ㅎㅎ

### 20220206

[10 Popular JavaScript methods implemented from scratch ](https://dev.to/northwillov/10-popular-javascript-methods-implemented-from-scratch-1ohk)

- 한번씩 생각해보는것도 나쁘지 않은듯

[Remix vs. Next: Which React Meta-Framework Should You Use?](http://prismic.io/blog/compare-remix-vs-nextjs)

- 간단 비교글
- 요즘 자주 보이는것은 `Remix`, `Vite` 정도.

[Is It Time To Say Goodbye To Webpack](https://javascript.plainenglish.io/time-to-say-goodbye-to-webpack-5bf06ff48823)

- 뭔가 개발할때에 빠른 빌드 속도로 사용하면 좋아보이는데 직접 써보진 않아서 잘 판단이 안된다.
- 저자도 단순 webpack 만 사용한다면 vite 를 추천하지만 많은 config 가 들어가있는 webpack을 사용하고 있다면 그리 추천하진 않는다.

[Bundle Up a JavaScript Project Using Esbuild](https://betterprogramming.pub/bundle-up-a-javascript-project-using-esbuild-b2c824ba0d39)

- 다음에 모듈 만들때에 webpack사용하기 보다는 esbuild 한번 써봐야겠다.

[There’s No Such Thing as Clean Code](https://www.steveonstuff.com/2022/01/27/no-such-thing-as-clean-code)

- 클린이라는 기준은 저마다 다름
- 클린 하다라는 것은 단순히 좋다 정도의 수준 밖에 안됨.
- 클린하게 하세요 보다는 보다 명확하고 구체적으로 어떤점이 좋고 나쁨을 설명하는것이 더 좋음
- [Geek news](https://news.hada.io/topic?id=5881&utm_source=slack&utm_medium=bot&utm_campaign=T029KCR8S3S)

[How to use Throttle and Debounce Callbacks in React with Hooks](https://szaranger.medium.com/how-to-use-throttle-and-debounce-callbacks-in-react-with-hooks-c07dbf79a973)

- 간단한 debounce/throttle 사용 예제
- useMemo 로 감싸서 사용함

### 20220205

[Real-time Updates: Polling, SSE and Web Sockets](https://dev.to/thesanjeevsharma/real-time-updates-polling-sse-and-web-sockets-277i)

- polling, sse, websocket 을 구현가능하다.
- sse 는 몰랐었다.
- [웹소켓 과 SSE(Server-Sent-Event) 차이점 알아보고 사용해보기](https://surviveasdev.tistory.com/entry/%EC%9B%B9%EC%86%8C%EC%BC%93-%EA%B3%BC-SSEServer-Sent-Event-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0)

[What is DevOps? REALLY understand it](https://dev.to/techworld_with_nana/what-is-devops-really-understand-it-29j7)

- 개발과 운영 사이에서 간극을 줄여주는 역할
- Miscommunication, Conflict of Interest, Security, Application Testing, Manual Work 이런문제점 들을 해결하며 안정적이고 빠른 배포를 위해 필요한 역할

[Avoid React Re-Renders with Automatic Batching](https://blog.bitsrc.io/avoid-react-re-renders-with-automatic-batching-dc8a76ce6de4)

- 사용자 인터렉션에 의한 변화 (클릭 같은) 거에서만 배칭이 일어났음
- state 가 바뀔때마다 바로 리렌더하는게 아니라 한번에 적용시키는걸 배칭이라고함
- 그런데 setTimeout, fetch, event listener 에서는 배칭이 일어나지 않아서 그안에서는 state 가 바뀔때마다 리렌더가 일어남
- React 18 부터는 이제 수정되어 위와 같은 상황에서도 배칭됨

### 20220201

[Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior](https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/)

- React always recursively renders components by default, so when a parent renders, its children will render
- Rendering by itself is fine - it's how React knows what DOM changes are needed
- But, rendering takes time, and "wasted renders" where the UI output didn't change can add up
- It's okay to pass down new references like callback functions and objects most of the time
- APIs like `React.memo()` can skip unnecessary renders if props haven't changed
- But if you always pass new references down as props, `React.memo()` can never skip a render, so you may need to memoize those values

- Context makes values accessible to any deeply nested component that is interested
- Context providers compare their value by reference to know if it's changed
- A new context values does force all nested consumers to re-render
- But, many times the child would have re-rendered anyway due to the normal parent->child render cascade process
- So you probably want to wrap the child of a context provider in `React.memo()`, or use `{props.children}`, so that the whole tree doesn't render all the time when you update the context value
- When a child component is rendered based on a new context value, React keeps cascading renders down from there too

- React-Redux uses subscriptions to the Redux store to check for updates, instead of passing store state values by context
- Those subscriptions run on every Redux store update, so they need to be as fast as possible
- React-Redux does a lot of work to ensure that only components whose data changed are forced to re-render
- connect acts like `React.memo()`, so having lots of connected components can minimize the total number of components that render at a time
- `useSelector` is a hook, so it can't stop renders caused by parent components.
- An app that only has `useSelector` everywhere should probably add `React.memo()` to some components to help avoid renders from cascading all the time.

[CSS 역사로 알아보는 CSS가 어려워진 이유](https://velog.io/@teo/css-history-1)

- CSS는 문서에서 서식과 컨텐츠를 분리하기 위해서 만들어졌다.
- 컨텐츠를 제공하는 솔루션을 기반으로 CSS를 커스텀하게 방식으로 발전했다.
- 그로인해 시멘틱 웹과 복잡한 Selector를 사용하는 방식으로 진화했다.
- CSS의 규모가 커져가는데 CSS의 발전은 늦어지자 CSS의 문법을 확장시키고자하는 방향으로 발전함.
- 프론트엔드는 백엔드는 데이터만 처리하는 웹 애플리케이션 방식으로 발전했다.
- 문서를 만드는 방법으로 애플리케이션을 만들어야 하는 과도기를 겪어갔다.
- Flexbox라는 애플리케이션을 위한 스펙들이 활성화되기 시작함.
- 컴포넌트를 기반으로 하는 프레임워크가 보편화되면서 CSS의 구조상의 문제가 드러남.
- Selector는 단순화되는 방향으로 진화하며 컴포넌트 개발방식에 맞는 CSS설계가 주요아젠다가됨.
- CSS 방법론은 BEM이 살아남았으나 CSS 구조의 한계를 느끼고 JS로 CSS의 부족함을 메꾸려는 방향으로 발전함. - PostCSS, CSSModules, CSS in JS
- CSS 자체적으로는 Utiliy-First라는 TailwindCSS가 새로운 대안으로 떠오름.
- IE11의 방파제가 무너지면서 Grid Layout이나 CSS Variable과 같은 CSS의 새로운 스펙들의 사용빈도가 높아지고 있음.
- 현재는 CSS in JS, Atomic CSS 2가지 갈래의 방향으로 프레임워크와 번들 생태계와 함께 진화중

[DOM은 다들 어떤식으로 공부하셨나요?](https://velog.io/@teo/dom)

- 이전에는 DOM 을 다루는 방법을 배우고 그다음에 프레임워크를 사용하는 방법을 배웠었음
- 당연히 발전이 그렇게 되었기 때문임. 허나 요즘에는 리액트, 앵귤러, 뷰 같은 프러엠워크를 먼저 배우고 후에 DOM 을 다루는방법을 배우려다 보니 어려움
- 간단한 jQuery 같은 프레임워크나 팝 오버 를 만들어 보면서 DOM 에 익숙해지는것도 좋은 방법임
